--- a/src/dns-manager/nm-dns-manager.c
+++ b/src/dns-manager/nm-dns-manager.c
@@ -147,6 +147,10 @@ struct _NMDnsManagerClass {
 	GObjectClass parent;
 };
 
+#ifndef RESOLV_CONF
+#define RESOLV_CONF "/var/volatile/etc/resolv.conf"
+#endif
+
 G_DEFINE_TYPE (NMDnsManager, nm_dns_manager, G_TYPE_OBJECT)
 
 NM_DEFINE_SINGLETON_INSTANCE (NMDnsManager);
@@ -651,6 +655,7 @@ dispatch_resolvconf (NMDnsManager *self,
 
 static SpawnResult
 update_resolv_conf (NMDnsManager *self,
+                    const char *resolv_path,
                     char **searches,
                     char **nameservers,
                     char **options,
@@ -663,7 +668,7 @@ update_resolv_conf (NMDnsManager *self,
 	gs_free char *content = NULL;
 	SpawnResult write_file_result = SR_SUCCESS;
 	int errsv;
-	const char *rc_path = _PATH_RESCONF;
+	const char *rc_path = resolv_path;
 	nm_auto_free char *rc_path_real = NULL;
 
 	/* If we are not managing /etc/resolv.conf and it points to
@@ -834,7 +839,7 @@ update_resolv_conf (NMDnsManager *self,
 		return SR_ERROR;
 	}
 
-	if (symlink (MY_RESOLV_CONF, RESOLV_CONF_TMP) == -1) {
+	if (symlink (RESOLV_CONF, RESOLV_CONF_TMP) == -1) {
 		errsv = errno;
 		g_set_error (error,
 		             NM_MANAGER_ERROR,
@@ -1161,7 +1166,7 @@ update_dns (NMDnsManager *self,
 		switch (priv->rc_manager) {
 		case NM_DNS_MANAGER_RESOLV_CONF_MAN_SYMLINK:
 		case NM_DNS_MANAGER_RESOLV_CONF_MAN_FILE:
-			result = update_resolv_conf (self, searches, nameservers, options, error, priv->rc_manager);
+			result = update_resolv_conf (self, RESOLV_CONF, searches, nameservers, options, error, priv->rc_manager);
 			resolv_conf_updated = TRUE;
 			break;
 		case NM_DNS_MANAGER_RESOLV_CONF_MAN_RESOLVCONF:
@@ -1178,7 +1183,7 @@ update_dns (NMDnsManager *self,
 		if (result == SR_NOTFOUND) {
 			_LOGD ("update-dns: program not available, writing to resolv.conf");
 			g_clear_error (error);
-			result = update_resolv_conf (self, searches, nameservers, options, error, NM_DNS_MANAGER_RESOLV_CONF_MAN_SYMLINK);
+			result = update_resolv_conf (self, RESOLV_CONF, searches, nameservers, options, error, NM_DNS_MANAGER_RESOLV_CONF_MAN_SYMLINK);
 			resolv_conf_updated = TRUE;
 		}
 	}
@@ -1186,7 +1191,7 @@ update_dns (NMDnsManager *self,
 	/* Unless we've already done it, update private resolv.conf in NMRUNDIR
 	   ignoring any errors */
 	if (!resolv_conf_updated)
-		update_resolv_conf (self, searches, nameservers, options, NULL, NM_DNS_MANAGER_RESOLV_CONF_MAN_UNMANAGED);
+		update_resolv_conf (self, RESOLV_CONF, searches, nameservers, options, NULL, NM_DNS_MANAGER_RESOLV_CONF_MAN_UNMANAGED);
 
 	/* signal that resolv.conf was changed */
 	if (update && result == SR_SUCCESS)
@@ -1286,6 +1291,89 @@ forget_data (NMDnsManager *self, NMDnsIP
 }
 
 static gboolean
+xc_rewrite_resolv_conf (NMDnsManager *self,
+            const char *iface,
+            gpointer config,
+            gboolean no_caching,
+            GError **error)
+{
+       NMDnsManagerPrivate *priv;
+       NMResolvConfData rc;
+       GSList *iter, *vpn_configs = NULL, *dev_configs = NULL, *other_configs = NULL;
+       const char *nis_domain = NULL;
+       char **searches = NULL;
+       char **nameservers = NULL;
+       char **nis_servers = NULL;
+       char **options = NULL;
+       int num, i, len;
+       gboolean success = FALSE, caching = FALSE;
+       char resolv_path[PATH_MAX];
+
+       rc.nameservers = g_ptr_array_new ();
+       rc.searches = g_ptr_array_new ();
+       rc.options = g_ptr_array_new ();
+       rc.nis_domain = NULL;
+       rc.nis_servers = g_ptr_array_new ();
+
+       if (config){
+              if (NM_IS_IP4_CONFIG (config))
+                     merge_one_ip4_config (&rc, (NMIP4Config *) config);
+       }
+
+       /* Per 'man resolv.conf', the search list is limited to 6 domains
+        * totalling 256 characters.
+       */
+       num = MIN (rc.searches->len, 6);
+       for (i = 0, len = 0; i < num; i++) {
+              len += strlen (rc.searches->pdata[i]) + 1; /* +1 for spaces */
+              if (len > 256)
+                      break;
+       }
+       g_ptr_array_set_size (rc.searches, i);
+       if (rc.searches->len) {
+               g_ptr_array_add (rc.searches, NULL);
+               searches = (char **) g_ptr_array_free (rc.searches, FALSE);
+       } else
+              g_ptr_array_free (rc.searches, TRUE);
+
+       if (rc.nameservers->len) {
+               g_ptr_array_add (rc.nameservers, NULL);
+               nameservers = (char **) g_ptr_array_free (rc.nameservers, FALSE);
+       } else
+               g_ptr_array_free (rc.nameservers, TRUE);
+
+       if (rc.nis_servers->len) {
+               g_ptr_array_add (rc.nis_servers, NULL);
+               nis_servers = (char **) g_ptr_array_free (rc.nis_servers, FALSE);
+       } else
+               g_ptr_array_free (rc.nis_servers, TRUE);
+
+       if (rc.options->len) {
+               g_ptr_array_add (rc.options, NULL);
+               options = (char **) g_ptr_array_free (rc.options, FALSE);
+       } else
+               g_ptr_array_free (rc.options, TRUE);
+
+       nis_domain = rc.nis_domain;
+
+       strcpy(resolv_path, RESOLV_CONF);
+       strcat(resolv_path, ".");
+       strcat(resolv_path, iface);
+
+       if (success == FALSE)
+               success = update_resolv_conf (self, resolv_path, searches, nameservers, options, error, NM_DNS_MANAGER_RESOLV_CONF_MAN_FILE);
+
+       if (searches)
+               g_strfreev (searches);
+       if (nameservers)
+               g_strfreev (nameservers);
+       if (nis_servers)
+               g_strfreev (nis_servers);
+
+       return success;
+}
+
+static gboolean
 nm_dns_manager_add_ip_config (NMDnsManager *self,
                               const char *iface,
                               gpointer config,
@@ -1344,9 +1432,17 @@ nm_dns_manager_add_ip_config (NMDnsManag
 		g_clear_error (&error);
 	}
 
+	if (!xc_rewrite_resolv_conf (self, iface, config, FALSE, &error)) {
+			_LOGW ("Could not commit DNS changes: (%d) %s",
+				error ? error->code : -1,
+				error && error->message ? error->message : "(unknown)");
+		g_clear_error (&error);
+	}
+
 	return TRUE;
 }
 
+
 gboolean
 nm_dns_manager_add_ip4_config (NMDnsManager *self,
                                const char *iface,
--- a/src/nm-policy.c
+++ b/src/nm-policy.c
@@ -472,8 +472,10 @@ update_ip4_routing (NMPolicy *self, gboo
 	}
 	g_assert ((best || vpn) && best_ac);
 
+#if 0
 	if (!force_update && best && (best == priv->default_device4))
 		return;
+#endif
 
 	if (best) {
 		const GSList *connections, *iter;
--- a/src/platform/nm-linux-platform.c
+++ b/src/platform/nm-linux-platform.c
@@ -2284,6 +2284,7 @@ _nl_msg_new_route (int nlmsg_type,
                    int nlmsg_flags,
                    int family,
                    int ifindex,
+                   int table,
                    NMIPConfigSource source,
                    unsigned char scope,
                    gconstpointer network,
@@ -2297,7 +2298,7 @@ _nl_msg_new_route (int nlmsg_type,
 	struct rtmsg rtmsg = {
 		.rtm_family = family,
 		.rtm_tos = 0,
-		.rtm_table = RT_TABLE_MAIN, /* omit setting RTA_TABLE attribute */
+		.rtm_table = table,
 		.rtm_protocol = nmp_utils_ip_config_source_coerce_to_rtprot (source),
 		.rtm_scope = scope,
 		.rtm_type = RTN_UNICAST,
@@ -5756,11 +5757,41 @@ ip4_route_add (NMPlatform *platform, int
 {
 	NMPObject obj_id;
 	nm_auto_nlmsg struct nl_msg *nlmsg = NULL;
+	const char *iface = NULL;
+
+	iface = nm_platform_link_get_name(platform, ifindex);
+	if (iface) {
+		int table = 30 + ifindex;
+		guint32 oxt_metric = metric;
+		NMPObject oxt_obj_id;
+		nm_auto_nlmsg struct nl_msg *oxt_nlmsg = NULL;
+
+		if(strncmp(iface, "brbridged", 9) != 0)
+			metric = metric + 1;
+
+		oxt_nlmsg = _nl_msg_new_route (RTM_NEWROUTE,
+		                           NLM_F_CREATE | NLM_F_REPLACE,
+		                           AF_INET,
+		                           ifindex,
+					   table,
+		                           source,
+		                           gateway ? RT_SCOPE_UNIVERSE : RT_SCOPE_LINK,
+		                           &network,
+		                           plen,
+		                           &gateway,
+		                           oxt_metric,
+		                           mss,
+		                           pref_src ? &pref_src : NULL);
+
+		nmp_object_stackinit_id_ip4_route (&oxt_obj_id, ifindex, network, plen, oxt_metric);
+		do_add_addrroute (platform, &oxt_obj_id, oxt_nlmsg);
+	}
 
 	nlmsg = _nl_msg_new_route (RTM_NEWROUTE,
 	                           NLM_F_CREATE | NLM_F_REPLACE,
 	                           AF_INET,
 	                           ifindex,
+				   RT_TABLE_MAIN,
 	                           source,
 	                           gateway ? RT_SCOPE_UNIVERSE : RT_SCOPE_LINK,
 	                           &network,
@@ -5786,6 +5817,7 @@ ip6_route_add (NMPlatform *platform, int
 	                           NLM_F_CREATE | NLM_F_REPLACE,
 	                           AF_INET6,
 	                           ifindex,
+				   RT_TABLE_MAIN,
 	                           source,
 	                           !IN6_IS_ADDR_UNSPECIFIED (&gateway) ? RT_SCOPE_UNIVERSE : RT_SCOPE_LINK,
 	                           &network,
@@ -5808,6 +5840,35 @@ ip4_route_delete (NMPlatform *platform,
 
 	nmp_object_stackinit_id_ip4_route (&obj_id, ifindex, network, plen, metric);
 
+	const char *iface = NULL;
+	iface = nm_platform_link_get_name(platform, ifindex);
+	if (iface) {
+		int table = 30 + ifindex;
+		guint32 oxt_metric = metric;
+		NMPObject oxt_obj_id;
+		nm_auto_nlmsg struct nl_msg *oxt_nlmsg = NULL;
+
+		if(strncmp(iface, "brbridged", 9) != 0)
+			metric = metric + 1;
+
+		nmp_object_stackinit_id_ip4_route (&oxt_obj_id, ifindex, network, plen, oxt_metric);
+		oxt_nlmsg = _nl_msg_new_route (RTM_DELROUTE,
+		                           0,
+		                           AF_INET,
+		                           ifindex,
+					   table,
+		                           NM_IP_CONFIG_SOURCE_UNKNOWN,
+		                           RT_SCOPE_NOWHERE,
+		                           &network,
+		                           plen,
+		                           NULL,
+		                           oxt_metric,
+		                           0,
+		                           NULL);
+		if (oxt_nlmsg)
+			do_delete_object (platform, &oxt_obj_id, oxt_nlmsg);
+	}
+
 	if (metric == 0) {
 		/* Deleting an IPv4 route with metric 0 does not only delete an exectly matching route.
 		 * If no route with metric 0 exists, it might delete another route to the same destination.
@@ -5841,6 +5902,7 @@ ip4_route_delete (NMPlatform *platform,
 	                           0,
 	                           AF_INET,
 	                           ifindex,
+				   RT_TABLE_MAIN,
 	                           NM_IP_CONFIG_SOURCE_UNKNOWN,
 	                           RT_SCOPE_NOWHERE,
 	                           &network,
@@ -5867,6 +5929,7 @@ ip6_route_delete (NMPlatform *platform,
 	                           0,
 	                           AF_INET6,
 	                           ifindex,
+				   RT_TABLE_MAIN,
 	                           NM_IP_CONFIG_SOURCE_UNKNOWN,
 	                           RT_SCOPE_NOWHERE,
 	                           &network,
--- a/src/devices/nm-device.c
+++ b/src/devices/nm-device.c
@@ -1632,7 +1632,7 @@ carrier_changed (NMDevice *self, gboolea
 			nm_device_activate_stage3_ip6_start (self);
 
 		return;
-	} else if (nm_device_get_enslaved (self) && !carrier) {
+	} else if (nm_device_get_enslaved (self) && !carrier && strncmp(priv->iface, "eth", 3)) {
 		/* Slaves don't deactivate when they lose carrier; for
 		 * bonds/teams in particular that would be actively
 		 * counterproductive.
@@ -1659,7 +1659,11 @@ carrier_changed (NMDevice *self, gboolea
 			nm_device_update_dynamic_ip_setup (self);
 		}
 	} else {
-		if (priv->state == NM_DEVICE_STATE_UNAVAILABLE) {
+		if (strncmp (priv->iface, "eth", 3) == 0) {
+			nm_device_queue_state (self, NM_DEVICE_STATE_DISCONNECTED,
+		        	               NM_DEVICE_STATE_REASON_CARRIER);
+		}
+		else if (priv->state == NM_DEVICE_STATE_UNAVAILABLE) {
 			if (nm_device_queued_state_peek (self) >= NM_DEVICE_STATE_DISCONNECTED)
 				nm_device_queued_state_clear (self);
 		} else {
@@ -2622,6 +2626,7 @@ slave_state_changed (NMDevice *slave,
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	gboolean release = FALSE;
 	gboolean configure = TRUE;
+	const char *iface = nm_device_get_iface (slave);
 
 	_LOGD (LOGD_DEVICE, "slave %s state change %d (%s) -> %d (%s)",
 	       nm_device_get_iface (slave),
@@ -2648,7 +2653,7 @@ slave_state_changed (NMDevice *slave,
 	if (reason == NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED)
 		configure = FALSE;
 
-	if (release) {
+	if (release && strncmp (iface, "eth", 3)) {
 		nm_device_master_release_one_slave (self, slave, configure, reason);
 		/* Bridge/bond/team interfaces are left up until manually deactivated */
 		if (priv->slaves == NULL && priv->state == NM_DEVICE_STATE_ACTIVATED)
--- a/src/devices/nm-device-ethernet-utils.c
+++ b/src/devices/nm-device-ethernet-utils.c
@@ -31,6 +31,7 @@ nm_device_ethernet_utils_get_default_wir
 	guint j;
 	int i;
 
+	return NULL;
 	/* Find the next available unique connection name */
 	for (i = 1; i <= 10000; i++) {
 		temp = g_strdup_printf (_("Wired connection %d"), i);
@@ -45,6 +46,5 @@ next:
 		;
 	}
 
-	return NULL;
 }
 
